package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"

	"github.com/anurag-rajawat/api-security/graph/generated"
	"github.com/anurag-rajawat/api-security/graph/model"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// ID resolver for ApiEvent
func (r *apiEventResolver) ID(ctx context.Context, obj *model.ApiEvent) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("cannot resolve ID on nil ApiEvent")
	}

	// GQLID should be populated in the APIEvents resolver after fetching
	if obj.GQLID == "" && obj.BSONID != primitive.NilObjectID {
		// Populate if somehow missed (should be populated post-fetch)
		obj.GQLID = obj.BSONID.Hex()
	} else if obj.GQLID == "" {
		return "", fmt.Errorf("ApiEvent missing ID information")
	}
	return obj.GQLID, nil
}

// APIEvents is the resolver for the apiEvents field.
func (r *queryResolver) APIEvents(ctx context.Context, filters *model.Filters) (*model.APIEventConnection, error) {
	if filters == nil {
		return nil, fmt.Errorf("filters argument is required")
	}
	r.Logger.Infow("APIEvents resolver called", "filters", filters)

	tenantId, found := extractTenantId(ctx)
	if !found {
		return nil, fmt.Errorf("no tenant id found in context")
	}

	isForwardPagination := filters.First != nil || filters.Last != nil
	isBackwardPagination := filters.Last != nil || filters.Before != nil
	if isForwardPagination && isBackwardPagination {
		return nil, fmt.Errorf("cannot use `first`/`after` and `last`/`before` arguments simultaneously")
	}

	baseQuery, err := r.buildContentFilters(filters)
	if err != nil {
		r.Logger.Errorw("Failed to build content filters", "error", err)
		return nil, fmt.Errorf("error building filters: %w", err)
	}

	sortDoc := r.buildSortDocument(filters.SortBy, isBackwardPagination)

	limit, fetchLimit := r.calculatePaginationLimits(filters.First, filters.Last)

	cursorFilter, err := r.buildCursorFilter(sortDoc, filters.After, filters.Before)
	if err != nil {
		return nil, err
	}

	finalQuery := append(bson.D{}, baseQuery...)
	if len(cursorFilter) > 0 {
		finalQuery = append(finalQuery, cursorFilter...)
	}

	collectionName := "obs_event_" + tenantId
	collection := r.mongoHandler.Database.Collection(collectionName)

	// Fetch Total Count (respects content filters)
	totalCount, err := collection.CountDocuments(ctx, baseQuery)
	if err != nil {
		r.Logger.Errorw("Failed to get total count", "query", baseQuery, "error", err)
		return nil, fmt.Errorf("failed to get total count: %w", err)
	}

	// Fetch Actual Data
	fetchedEvents, err := r.fetchAPIEvents(ctx, collection, finalQuery, sortDoc, int64(fetchLimit), totalCount)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch API events: %w", err)
	}

	resultsToReturn, hasNextPage, hasPreviousPage := r.processPaginationResults(
		fetchedEvents,
		limit,
		isBackwardPagination,
		filters.After,
		filters.Before,
	)

	connection := r.buildAPIEventConnection(resultsToReturn, pageInfoInput{
		totalCount:      totalCount,
		hasNextPage:     hasNextPage,
		hasPreviousPage: hasPreviousPage,
	})

	return connection, nil
}

// ApiEvent returns generated.ApiEventResolver implementation.
func (r *Resolver) ApiEvent() generated.ApiEventResolver { return &apiEventResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type apiEventResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
